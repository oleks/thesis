\section{The Thesis in Hindsight}

Implicit Computational Complexity (ICC) is concerned with ``implicitly''
characterising known computational complexity classes, without reference to a
particular machine model --- the computational complexity of constructible
programs depends on the choice of laws that govern their construction.

Of particular interest, are laws that govern the \emph{manipulation of values},
the \emph{formation of functions}, and the \emph{construction of types}. The
choice of laws itself, has an impact on the definable algorithms, their
efficiency, as well as the mental complexity inherent in programming within the
confines of the system.
 
Fundamentally interested in practically feasible programs, the class \FPTIME{},
of functions computable in polynomial time on a Turing machine, is considered.
Although not all functions in \FPTIME{} are practically feasible, and not all
practically feasible functions are in \FPTIME{} --- there is a wealth of
literature attempting to ``capture'' \PTIME{} and \FPTIME{} in particular.
(Where \PTIME{} is the class of decision problems decidable in polynomial time
on a Turing machine.)

The methods surveyed can be categorised as follows:

\begin{enumerate}[label=\roman*.]

\item bounded primitive recursion on notation, as in \cite{cobham-1965};

\item predicative recursion, as in \cite{bellantoni-cook-1992, leivant-1995,
niggl-2005};

\item non-size increasing computation, as in \cite{jones-1999, hofmann-2003};

\item polynomially bounded value computation, as in
\cite{niggl-wunderlich-2006, jones-kristiansen-2009}; and

\item substructural bounds, as in \cite{girard-scedorov-scott-1992,
girard-1998}.

\end{enumerate}

Starting out recursion theoretically, the low order numerals above deal in the
computation of functions over natural numbers, at best in natural numbers in
$n$-ary notation.  We explore the horizon of their applicability to more
colloqial data types, hereunder general lists, trees, graphs, and of course,
functions.

Bearing similar clothes, recursion theoretic results are notoriously limited in
algorithmic expressiveness, not least because the leap from ``primitive
recursion'' to ``general recursion'' (and so to Turing-completeness) can be
taken by adding a mere ``minimization operator''. It appears that tighter
characterisations are better thought in studying the use and abuse of values
throughout a recursion, which is the subject matter of the high order numerals
above.

Besides sketching ``how well'' these methods ``capture'' \PTIME{} or \FPTIME{},
their applicability to enforcing subpolynomial time bounds is considered.
Space, or at least, value size bounds, often shape the time bounds at hand, but
are not considered on their own right. This is left to future survey work.

In attempt to ``capture'' some subpolynomial time bounds, enriching the
``resource type'' of \cite{hofmann-2003, aehlig-schwichtenberg-2002} to
slightly more general effect types\cite{gifford-lucassen-1986} is considered in
detail.

A setback of a type-system based approach is that the programmer cannot
immediately be presented with the grammar of admissible programs, having stated
a particular bound. This can be considered useful to writing programs within
the given bound (rather than having to deal with type errors). This is remedied
by an automatic procedure for generating a context-free grammar for valid terms
of a given (sufficiently simple) type.  In effect, producing the grammar of
admissible programs on demand.

Considering the original thesis proposal and tasks, it is perhaps about as
na\"ive as a thesis onset can be. To the unwitting surprise of the author,
Implicit Computational Complexity is a comprehensive and manifold area of
research. The thesis proposal has grown to become as given above.
Never-the-less, the original learning objectives, as stated in the same
contract, \emph{seem} to comply with the body of work in this document:

\begin{enumerate}[label=(\alph*)]

\item Find and survey previous work in an area of research in Computer Science.

\item Explain and contrast this work in a matter understandable to those
unfamiliar the research area, but familiar with Computer Science in general. 

\item Prove that a computational complexity class defined in terms of the
logical principles of a programming language, is equivalent to a computational
complexity class defined in terms of the costs induced on a particular machine
model. 

\item Devise a programming language, where the programmer can state, and be
statically guaranteed, a computational bound on parts of the program.

\end{enumerate}

In hindsight, the only serious drawback of this document wrt. the above
learning objectives \emph{seems} to be the lack of a discussion about an
\emph{implementation} of the said programming language. This is considered a
matter of future work.  (Perhaps in time for the thesis defense!)
