\section{The Thesis in Hindsight}

Implicit Computational Complexity (ICC) is concerned with ``implicitly''
characterising known computational complexity classes, without reference to a
particular machine model --- the computational complexity of constructible
programs depends on the choice of laws that govern their construction.

Of particular interest, are laws that govern the \emph{manipulation of values},
the \emph{formation of functions}, and the \emph{construction of types}. The
choice of laws itself, has an impact on the definable algorithms, their
efficiency, as well as the mental complexity inherent in programming within the
confines of the system.
 
Fundamentally interested in practically feasible programs, the class \FPTIME{},
of functions computable in polynomial time on a Turing machine, is considered.
Although not all functions in \FPTIME{} are practically feasible, and not all
practically feasible functions are in \FPTIME{} --- there is a wealth of
literature attempting to ``capture'' \PTIME{} and \FPTIME{} in particular.
(Where \PTIME{} is the class of decision problems decidable in polynomial time
on a Turing machine.)

The methods surveyed can be categorised as follows:

\begin{enumerate}[label=\roman*.]

\item bounded primitive recursion on notation, as in \cite{cobham-1965};

\item predicative recursion, as in \cite{bellantoni-cook-1992, leivant-1995,
niggl-2005};

\item non-size increasing computation, as in \cite{jones-1999, hofmann-2003};

\item polynomially bounded value computation, as in
\cite{niggl-wunderlich-2006, jones-kristiansen-2009}; and

\item substructural bounds, as in \cite{girard-scedorov-scott-1992,
girard-1998}.

\end{enumerate}

Besides sketching \emph{how well} these methods ``capture'' \PTIME{} or
\FPTIME{}, their applicability to enforcing subpolynomial time bounds is
considered.  Space, or at least, value size bounds, often shape the time bounds
at hand, but are not considered on their own right. This is left to future
survey work.

In attempt to ``capture'' some subpolynomial time bounds, enriching the
``resource type'' of \cite{hofmann-2003, aehlig-schwichtenberg-2002} to
slightly more general effect types\cite{gifford-lucassen-1986} is considered in
detail.

A setback of a type-system based approach is that the programmer cannot
immediately be presented with the grammar of admissible programs, having stated
a particular bound. This can be considered useful to writing programs within
the given bound (rather than having to deal with type errors). This is remedied
by an automatic procedure for generating a context-free grammar for valid terms
of a given (sufficiently simple) type.  In effect, producing the grammar of
admissible programs on demand.
