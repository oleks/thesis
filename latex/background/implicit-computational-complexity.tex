\chapter{Implicit Computational Complexity} \label{sec:icc}

In \refSec{computational-complexity}, we characterised a range of complexity
classes in terms of the costs incurred on a particular machine model. This
reflects perhaps a real-world motivation for the theory of computational
complexity --- some interesting programs actually get executed by machines.
Such characterisations have proven theoretically well-founded as well, as
certain complexity classes appear nearly equivalent, regardless of the choice
of machine model, e.g. PTIME.

\emph{Implicit Computational Complexity} (ICC) seeks instead to give
``machine-independent'' characterisations of these complexity classes.  The
benefit of such a characterisation is that it can serve as a foundation for the
design of programming languages where all programs are guaranteed by
construction to lie within the characterised complexity class.

In \refSec{computability}, where we introduced the notion of a Turing machine,
we also gave a ``machine-independent'' characterisation of what it is that a
Turing machine computes. This was a ``mathematical'' characterisation. With
such a ``machine-avoidant'' foundation as classical mathematics, such
characterisations are of little use, but it gave a motivating example.

ICC is instead founded in either recursion theory\cite{cobham-1965,
bellantoni-cook-1992, leivant-1995, marion-2009}, proof
theory\cite{girard-scedorov-scott-1992, leivant-1994, girard-1998,
asperti-roversi-2002, lafont-2004, dal-lago-hofmann-2010}, term rewriting
systems\cite{beckmann-weiermann-1996, bonfante-et-al-1999, avanzini-et-al-2012,
de-carvalho-simonsen-2014}, programming
languages\cite{voda-1994,jones-1999,kristiansen-niggl-2004,kristiansen-2005}, type
systems\cite{hofmann-2000b, crary-weirich-2000}, etc.

This diversity in foundations suggests that it is worthwhile to review and
evaluate  at least some of these characterisations. The comprehensive list of
citations suggests that it is beyond the scope of this thesis to cover all of
them. Instead, we will be guided by the surveys of \cite{clote-1999},
\cite{hofmann-2000a}, \cite{dal-lago-2012}, among others, occasionally delving
into details.

In general, we will evaluate a characterisations of a complexity class in terms
of two formal, and one informal parameter.

\begin{definition} \label{def:icc-soundness} A system $S$ is
$\mathcal{C}$-\textbf{sound} if all functions computable in $S$ lie in the
complexity class $\mathcal{C}$.\end{definition} 

A system $S$ can be proven to be $\mathcal{C}$-sound, by exhibiting a method of
simulating $S$ on a system $T$, which is already known to be
$\mathcal{C}$-sound, or on a system which can otherwise be limited in resources
to $\mathcal{C}$. For instance, we could simulate $S$ on a Turing machine with
resources bounded to $\mathcal{C}$.

\begin{definition} \label{def:icc-completeness} A system $S$ is
$\mathcal{C}$-\textbf{complete} if all functions in the complexity class
$\mathcal{C}$ are computable in $S$.\end{definition}

We gather soundness and completeness under a single notion of ``capture'':

\begin{definition} \label{def:icc-capture} A system $S$ \textbf{captures} a
complexity class $\mathcal{C}$ if $S$ is both $\mathcal{C}$-sound and
$\mathcal{C}$-complete.  \end{definition}

\refDef{icc-soundness} and \refDef{icc-completeness} appeal to the
``computation of (mathematical) functions'' rather than ``programs''. Of
course, there are (uncountably) infinitely many programs computing the same
function, and the vast majority of them may be rejected by a system $S$ by
virtue of its characterisation of a particular complexity class. Perhaps so
much so, that a programmer may find $S$ to be rather ``inexpressive''. This
leads way for the last, informal parameter which we'll use for comparing ICC
characterisations:

\begin{notion} A system $S$ is \textbf{expressive} if it permits an eloquent
solution to a practical programming problem.\end{notion}

% not really aka, but in the spirit of the previous chapter, Implicit
% Complexity, and hence Implicit Complexity Theory

% Also, better suited as an introduction as it doesn't really say anything
% about the choice of polynomial time from the get go. That's more a
% coincidence, the following definitions will hold regardless. Perhaps it is
% worth it calling this a Part I: Introduction and Background

% Fragment of a logic means that we are restricted to a subset of the syntax,
% but retain the same semantics. If we choose the combination of words -
% subsystem of system, we are perhaps a little more free, but in either case,
% we probably have to further specify what we keep and what we take out.

% for the purposes of this thesis, we may regard logical systems equivalent to
% programming languages - draw inspiration from Types of Crash Prevention - it
% has a nice, human readable introduction to the whole thing.

% A system that is both intensionally sound and complete is often not
% recursively enumerable think, EQ(TM) which is neither Turing-recognisable,
% nor co-Turing-recognisable.

% Thus in practice, we strive to improve the intensional expressivitiy by
% capturing important classes of examples and patterns.
