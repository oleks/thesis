% vim: set spell:

\chapter{Computability}

\begin{notion} A problem is ``computable'' if it can be solved by transforming
a mathematical object over a finite amount of time, without ingenuity.
\end{notion}

Any attempt at a more definite notion of computability seems to arrive at a
philosophical impasse, where the notions of ``transformation'', ``mathematical
object'', and ``ingenuity'' form a philosophical conundrum. The indefinite
notion however, is sufficient to state the following theorem:

\begin{theorem} The class of computable problems is closed under
concatenation.\end{theorem}

That is, if a problem $P$ can be solved by solving a computable problem $Q$,
followed by solving a computable problem $R$, then $P$ itself is computable.

\begin{proof} Since both $Q$ and $R$ are computable, and no transformations are
performed, other than to solve the problems $Q$ and $R$, $P$ itself is
computable.\end{proof}

Thus we arrive at the common notion of an algorithm:

\begin{notion} An ``algorithm'' is a specification of how a problem can be
solved by performing a finite sequence of finite-time transformations of a
mathematical object, without ingenuity. \end{notion}

TODO:

\begin{itemize}

\item The classical result that primitive recursive functions are computable.
To argue for this, we probably need to argue for a type theoretic approach, in
that, what we can construct, we can compute. Function algebras should also be
introduced here.

\item General recursion (due to Kleene wrt. definition) and it's undecidability
(due to Church).

\item A different approach to computability: Post and Turing machines. Prove
their equivalence to general recursion above.

\end{itemize}

% At the time of writing, there are two prominent foundations for dealing with
% mathematical objects: set-theory and type-theory. With the set-theoretic
% foundation, mathematical objects are sets, or elements of sets, and we deal
% with propositions about these objects, i.e. statements which may or may not
% hold. With the type-theoretic foundation, mathematical objects are terms of
% particular types, and we deal with the construction of new terms from
% preexisting terms.

% The difference between these foundations lies in that the set-theoretic
% foundation requires an accompanying logic for stating propositions, while
% type theory can be self-contained.

% It follows that the set of computable problems is closed under composition,
% in the sense that a problem is computable if it can be solved by a finite
% sequence of finite-time transformations of a mathematical object, without
% ingenuity.

% Model Theory vs. Type Theory vs. Category Theory

% Primitive recursion - decidable.

% Mathematical objects are usually regarded in one of two fundamental ways: as
% sets, as in set theory, or as terms of particular types, as in type theory.
% In the first, we are concerned with sets which may or may not be members of
% other sets. In the second, we are concerned with terms of particular types,
% which may or may not be composable to construct terms of new types.

% The difference in approaches lies in that with set theory, we state
% predicates which determine membership in a set, whereas with type theory, we
% specify rules as to how to compose terms of particular types to form new
% types.

% Both deal with collections of elements. In the first, we are concerned with
% whether an element is a member of a particular set. In the second, we are
% concerned with whether a term of a particular type can be constructed.

% The original and final objects can be regarded as elements of the domain and
% codomain of a, necessarily computable, mathematical function.

% Mathematical functions are typically regarded in one of two fundamentally
% different ways: as \emph{sets}, as in set theory, or as \emph{types}, as in
% type theory. In the first case, a function defines a relation between between
% its domain and codomain. This superimposes two different ways of ``computing''
% a function: deciding membership in a set, or constructing a term of a
% particular type. (oleks, more than two ways! There are lots of ways to consider
% a function... )

% abstract rewriting

